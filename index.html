<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Interactive Water Globe</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #050510; /* 深宇宙のような背景 */
            touch-action: none; /* スマホでのスクロール防止 */
        }
        canvas {
            display: block;
            outline: none;
        }
    </style>
</head>
<body>

<script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
    }
  }
</script>

<script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    // 1. シーンのセットアップ
    const scene = new THREE.Scene();
    
    // フォグを追加して奥行き感を出す
    scene.fog = new THREE.FogExp2(0x050510, 0.002);

    // 2. カメラのセットアップ
    const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 0, 180); // 初期位置

    // 3. レンダラーのセットアップ（高画質・スマホ最適化）
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Retina対応しつつ負荷軽減
    document.body.appendChild(renderer.domElement);

    // 4. コントロール（インタラクティブ操作）
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true; // 慣性をつけて滑らかに
    controls.dampingFactor = 0.05;
    controls.rotateSpeed = 0.6;
    controls.enablePan = false; // 地球が画面外に行かないようにパンを無効化
    controls.minDistance = 110;
    controls.maxDistance = 300;
    controls.autoRotate = true; // 自動回転
    controls.autoRotateSpeed = 0.8;

    // 5. 地球の作成
    // テクスチャローダー
    const textureLoader = new THREE.TextureLoader();

    // NASA等の公開データに基づくテクスチャ（CORS対応のCDNを使用）
    // 陸地のマップ
    const earthMap = textureLoader.load('https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/planets/earth_atmos_2048.jpg');
    // 水域（海・湖）を光らせるためのスペキュラマップ
    const earthSpecular = textureLoader.load('https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/planets/earth_specular_2048.jpg');
    // 凹凸感
    const earthNormal = textureLoader.load('https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/planets/earth_normal_2048.jpg');

    const sphereGeometry = new THREE.SphereGeometry(50, 64, 64);

    // マテリアル設定（ここがデザインの肝）
    const earthMaterial = new THREE.MeshPhongMaterial({
        map: earthMap,
        specularMap: earthSpecular,
        normalMap: earthNormal,
        specular: new THREE.Color(0x00ffff), // 水域の反射色（シアン）
        shininess: 40, // 水の輝き度合い
        color: 0x333333, // 陸地のベース色（暗くする）
        emissive: 0x001133, // 全体のほんのりとした発光
        emissiveMap: earthSpecular, // 水域だけを発光させる
        emissiveIntensity: 0.6 // 発光強度
    });

    // 陸地を少し暗く、海を明るく調整するためのシェーダーハックの代わりに
    // マテリアルのプロパティで調整済み。
    // よりカラフルにするため、ライトの色で演出します。

    const earth = new THREE.Mesh(sphereGeometry, earthMaterial);
    scene.add(earth);

    // 6. 大気の作成（グロー効果）
    const atmosphereGeometry = new THREE.SphereGeometry(51, 64, 64);
    const atmosphereMaterial = new THREE.ShaderMaterial({
        vertexShader: `
            varying vec3 vNormal;
            void main() {
                vNormal = normalize(normalMatrix * normal);
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `,
        fragmentShader: `
            varying vec3 vNormal;
            void main() {
                float intensity = pow(0.6 - dot(vNormal, vec3(0, 0, 1.0)), 4.0);
                gl_FragColor = vec4(0.2, 0.6, 1.0, 1.0) * intensity;
            }
        `,
        blending: THREE.AdditiveBlending,
        side: THREE.BackSide,
        transparent: true
    });

    const atmosphere = new THREE.Mesh(atmosphereGeometry, atmosphereMaterial);
    scene.add(atmosphere);

    // 7. 背景の星屑（空間演出）
    const starsGeometry = new THREE.BufferGeometry();
    const starsCount = 2000;
    const posArray = new Float32Array(starsCount * 3);
    
    for(let i = 0; i < starsCount * 3; i++) {
        posArray[i] = (Math.random() - 0.5) * 800; // 広い範囲に配置
    }
    
    starsGeometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
    
    // 星の色をランダムでカラフルに
    const starMaterial = new THREE.PointsMaterial({
        size: 1.5,
        color: 0xffffff,
        transparent: true,
        opacity: 0.8,
        sizeAttenuation: true
    });
    
    const stars = new THREE.Points(starsGeometry, starMaterial);
    scene.add(stars);

    // 8. ライティング
    const ambientLight = new THREE.AmbientLight(0x333333); // 全体照明
    scene.add(ambientLight);

    const directionalLight = new THREE.DirectionalLight(0xffffff, 1.5);
    directionalLight.position.set(50, 30, 50);
    scene.add(directionalLight);

    // ネオン感を出すためのポイントライト（青と紫）
    const spotLight1 = new THREE.PointLight(0x00ffff, 2, 300);
    spotLight1.position.set(100, 100, 100);
    scene.add(spotLight1);

    const spotLight2 = new THREE.PointLight(0xff00ff, 1, 300); // 紫のアクセント
    spotLight2.position.set(-100, -50, 50);
    scene.add(spotLight2);


    // 9. アニメーションループ
    function animate() {
        requestAnimationFrame(animate);
        controls.update(); // 慣性や自動回転の更新
        
        // 星をゆっくり回転
        stars.rotation.y -= 0.0002;

        renderer.render(scene, camera);
    }

    // 10. リサイズ対応（スマホ回転時など）
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // 操作が始まったら自動回転を止める（UX向上）
    controls.addEventListener('start', () => {
        controls.autoRotate = false;
    });

    animate();
</script>
</body>
</html>
