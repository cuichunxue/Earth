<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>3D Rotating Earth (PBR)</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #000;
      height: 100%;
      width: 100%;
    }
    #app {
      width: 100vw;
      height: 100vh;
    }
    .info {
      position: absolute;
      top: 10px;
      left: 10px;
      padding: 6px 10px;
      background: rgba(0, 0, 0, 0.5);
      color: #fff;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      font-size: 12px;
      border-radius: 4px;
      z-index: 10;
    }
  </style>
</head>
<body>
<div id="app"></div>
<div class="info">
  ğŸ›° 3D Earth Demo â€“ Orbit: å·¦ãƒ‰ãƒ©ãƒƒã‚° / ã‚ºãƒ¼ãƒ : ãƒ›ã‚¤ãƒ¼ãƒ« / ãƒ‘ãƒ³: å³ãƒ‰ãƒ©ãƒƒã‚°
</div>

<script type="module">
  import * as THREE from 'https://unpkg.com/three@0.164.0/build/three.module.js';
  import { OrbitControls } from 'https://unpkg.com/three@0.164.0/examples/jsm/controls/OrbitControls.js';

  // --- åŸºæœ¬ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ— ------------------------------------------------------
  const container = document.getElementById('app');

  const scene = new THREE.Scene();
  // æ·±å®‡å®™ã£ã½ã„å°‘ã—ã ã‘é’å‘³ã®ã‚ã‚‹é»’
  scene.background = new THREE.Color(0x000008);

  const camera = new THREE.PerspectiveCamera(
    45,
    window.innerWidth / window.innerHeight,
    0.1,
    1000
  );
  // åœ°çƒã‹ã‚‰å°‘ã—é›¢ã‚ŒãŸä½ç½®
  camera.position.set(0, 0, 4);

  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setPixelRatio(window.devicePixelRatio);
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.outputColorSpace = THREE.SRGBColorSpace;
  renderer.toneMapping = THREE.ACESFilmicToneMapping;
  renderer.toneMappingExposure = 1.1;
  container.appendChild(renderer.domElement);

  const controls = new OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;
  controls.dampingFactor = 0.05;
  controls.enablePan = true;
  controls.minDistance = 1.8;
  controls.maxDistance = 10;

  // --- ãƒ©ã‚¤ãƒ†ã‚£ãƒ³ã‚°ï¼ˆå¤ªé™½å…‰ + å¼±ã„ç’°å¢ƒå…‰ï¼‰ -----------------------------------
  // å¤ªé™½å…‰ï¼ˆDirectionalLightï¼‰: æ˜¼å¤œå¢ƒç•Œã‚’ä½œã‚‹ä¸»å…‰æº
  const sunLight = new THREE.DirectionalLight(0xffffff, 2.0);
  // ä½ç½®ã¯ã€Œå¤ªé™½å´ã€ â€“ å¾Œã§æ–¹å‘ã‚’å¤‰ãˆã‚Œã°æ™‚é–“å¤‰åŒ–ã‚‚å¯èƒ½
  sunLight.position.set(5, 2, 3);
  scene.add(sunLight);

  // å¤œå´ãŒå®Œå…¨ã«çœŸã£é»’ã«ãªã‚Šã™ããªã„ã‚ˆã†ã«ã€å¼±ã„ç’°å¢ƒå…‰ã‚’è¿½åŠ 
  const ambientLight = new THREE.AmbientLight(0x222233, 0.6);
  scene.add(ambientLight);

  // --- ãƒ†ã‚¯ã‚¹ãƒãƒ£èª­ã¿è¾¼ã¿ ----------------------------------------------------
  const textureLoader = new THREE.TextureLoader();

  // â˜…ã“ã“ã‚’å®Ÿéš›ã®ãƒ•ã‚¡ã‚¤ãƒ«URLã«å·®ã—æ›¿ãˆã¦ãã ã•ã„ï¼ˆNASA Blue Marble / satellite ãªã©ï¼‰
  // ä¾‹:
  // const EARTH_ALBEDO_URL   = 'your_path/earth_albedo.jpg';
  // const EARTH_NORMAL_URL   = 'your_path/earth_normal.jpg';
  // const EARTH_ROUGH_URL    = 'your_path/earth_roughness.jpg';
  // const EARTH_METAL_URL    = 'your_path/earth_metallic.jpg';
  // const EARTH_AO_URL       = 'your_path/earth_ao.jpg';
  // const CLOUDS_ALPHA_URL   = 'your_path/clouds_alpha.png';
  const EARTH_ALBEDO_URL =  'textures/earth_albedo.jpg';   // åœ°è¡¨ã‚«ãƒ©ãƒ¼ï¼ˆBlue Marbleï¼‰
  const EARTH_NORMAL_URL =  'textures/earth_normal.jpg';   // æ³•ç·šãƒãƒƒãƒ—
  const EARTH_ROUGH_URL =   'textures/earth_roughness.jpg';
  const EARTH_METAL_URL =   'textures/earth_metallic.jpg';
  const EARTH_AO_URL =      'textures/earth_ao.jpg';
  const CLOUDS_ALPHA_URL =  'textures/earth_clouds_alpha.png';

  // --- åœ°è¡¨ãƒ¬ã‚¤ãƒ¤ãƒ¼ï¼ˆunit sphere, PBRãƒãƒ†ãƒªã‚¢ãƒ«ï¼‰ ---------------------------
  const radiusSurface = 1.0; // unit sphere
  const widthSegments = 128;
  const heightSegments = 128;

  const surfaceGeo = new THREE.SphereGeometry(radiusSurface, widthSegments, heightSegments);
  // aoMapç”¨ã«UV2ã‚’è¤‡è£½
  surfaceGeo.setAttribute('uv2', new THREE.BufferAttribute(surfaceGeo.attributes.uv.array, 2));

  const earthMaterial = new THREE.MeshStandardMaterial({
    color: 0xffffff,          // map(ã‚¢ãƒ«ãƒ™ãƒ‰)ã§ä¸Šæ›¸ãã•ã‚Œã‚‹
    metalness: 0.0,
    roughness: 1.0
  });

  // ãƒ†ã‚¯ã‚¹ãƒãƒ£èª­ã¿è¾¼ã¿ & é©ç”¨
  const earthAlbedo   = textureLoader.load(EARTH_ALBEDO_URL, () => { renderOnce(); });
  earthAlbedo.colorSpace = THREE.SRGBColorSpace;

  const earthNormal   = textureLoader.load(EARTH_NORMAL_URL, () => { renderOnce(); });
  const earthRough    = textureLoader.load(EARTH_ROUGH_URL, () => { renderOnce(); });
  const earthMetal    = textureLoader.load(EARTH_METAL_URL, () => { renderOnce(); });
  const earthAO       = textureLoader.load(EARTH_AO_URL, () => { renderOnce(); });

  earthMaterial.map          = earthAlbedo;
  earthMaterial.normalMap    = earthNormal;
  earthMaterial.roughnessMap = earthRough;
  earthMaterial.metalnessMap = earthMetal;
  earthMaterial.aoMap        = earthAO;

  // æµ·ã®ã‚¹ãƒšã‚­ãƒ¥ãƒ©åå°„ã‚’å¼·èª¿ã™ã‚‹ãŸã‚ã«ã€å…¨ä½“ã‚’ã‚„ã‚„ã€Œãƒ¡ã‚¿ãƒ«æ„Ÿ+ä½ãƒ©ãƒ•ãƒã‚¹ã€ã«å¯„ã›ã‚‹
  earthMaterial.metalness = 0.25;
  earthMaterial.roughness = 0.5;

  const earthMesh = new THREE.Mesh(surfaceGeo, earthMaterial);
  scene.add(earthMesh);

  // --- é›²ãƒ¬ã‚¤ãƒ¤ãƒ¼ ------------------------------------------------------------
  const radiusClouds = 1.02;
  const cloudsGeo = new THREE.SphereGeometry(radiusClouds, widthSegments, heightSegments);

  const cloudsTexture = textureLoader.load(CLOUDS_ALPHA_URL, () => { renderOnce(); });
  cloudsTexture.colorSpace = THREE.SRGBColorSpace;

  const cloudsMat = new THREE.MeshStandardMaterial({
    map: cloudsTexture,
    transparent: true,
    opacity: 0.8,
    depthWrite: false,
    side: THREE.DoubleSide
  });

  const cloudsMesh = new THREE.Mesh(cloudsGeo, cloudsMat);
  scene.add(cloudsMesh);

  // --- å¤§æ°—ãƒ¬ã‚¤ãƒ¤ãƒ¼ï¼ˆç°¡æ˜“Fresnelé¢¨ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ï¼‰ -----------------------------
  const radiusAtmosphere = 1.06;
  const atmosphereGeo = new THREE.SphereGeometry(radiusAtmosphere, 64, 64);

  const atmosphereVert = /* glsl */`
    varying vec3 vWorldPosition;
    void main() {
      vec4 worldPosition = modelMatrix * vec4(position, 1.0);
      vWorldPosition = worldPosition.xyz;
      gl_Position = projectionMatrix * viewMatrix * worldPosition;
    }
  `;

  const atmosphereFrag = /* glsl */`
    varying vec3 vWorldPosition;
    uniform vec3 cameraPositionWorld;
    void main() {
      // ã‚«ãƒ¡ãƒ©ã‹ã‚‰ã®è¦–ç·šæ–¹å‘
      vec3 viewDir = normalize(vWorldPosition - cameraPositionWorld);
      // æ³•ç·šã¯çƒã®ä¸­å¿ƒã‹ã‚‰å¤–å‘ã
      vec3 normal = normalize(vWorldPosition);

      // Fresnel é¢¨: ç¸ã»ã©å¼·ãç™ºå…‰
      float fresnel = pow(1.0 - max(dot(viewDir, normal), 0.0), 3.0);

      vec3 atmosphereColor = vec3(0.25, 0.5, 1.0); // é’ã£ã½ã„å¤§æ°—
      gl_FragColor = vec4(atmosphereColor * fresnel * 1.5, fresnel);
    }
  `;

  const atmosphereMat = new THREE.ShaderMaterial({
    vertexShader: atmosphereVert,
    fragmentShader: atmosphereFrag,
    uniforms: {
      cameraPositionWorld: { value: new THREE.Vector3() }
    },
    side: THREE.BackSide,
    transparent: true,
    blending: THREE.AdditiveBlending,
    depthWrite: false
  });

  const atmosphereMesh = new THREE.Mesh(atmosphereGeo, atmosphereMat);
  scene.add(atmosphereMesh);

  // --- æ˜ŸèƒŒæ™¯ï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ã®æ˜Ÿç©ºï¼‰ -------------------------------------------
  const starGeo = new THREE.SphereGeometry(50, 32, 32);
  const starMat = new THREE.MeshBasicMaterial({
    color: 0x050510,
    side: THREE.BackSide
  });
  const starMesh = new THREE.Mesh(starGeo, starMat);
  scene.add(starMesh);

  // --- ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ«ãƒ¼ãƒ— --------------------------------------------------
  const clock = new THREE.Clock();

  function animate() {
    requestAnimationFrame(animate);

    const delta = clock.getDelta();

    // åœ°çƒã®è‡ªè»¢ï¼ˆYè»¸ä¸­å¿ƒï¼‰
    earthMesh.rotation.y += delta * 0.1;     // ç´„ 0.1 rad / sec
    // é›²ã¯å°‘ã—é€Ÿãå‹•ã‹ã™
    cloudsMesh.rotation.y += delta * 0.15;

    // å¤§æ°—ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ã«ã‚«ãƒ¡ãƒ©ä½ç½®ã‚’æ¸¡ã™
    atmosphereMat.uniforms.cameraPositionWorld.value.copy(camera.position);

    controls.update();
    renderer.render(scene, camera);
  }

  // æœ€åˆã®æç”»ã ã‘èµ°ã‚‰ã›ãŸã„ã¨ãã«ä½¿ç”¨
  function renderOnce() {
    renderer.render(scene, camera);
  }

  animate();

  // --- ãƒªã‚µã‚¤ã‚ºå¯¾å¿œ ----------------------------------------------------------
  window.addEventListener('resize', onWindowResize, false);
  function onWindowResize() {
    const width = window.innerWidth;
    const height = window.innerHeight;

    camera.aspect = width / height;
    camera.updateProjectionMatrix();

    renderer.setSize(width, height);
  }
</script>
</body>
</html>
